Una tabella hash (in Python il tipo dict) è una struttura che associa una chiave ad un valore calcolando, a partire dalla chiave, un numero (“hash”) che individua direttamente la posizione in memoria dove il valore sarà conservato. L’operazione di calcolo dell’hash è molto rapida e, nella media, permette di ottenere inserimenti, ricerche e cancellazioni in tempo costante O(1). Se due chiavi producono lo stesso hash si parla di collisione: l’implementazione la gestisce con tecniche come l’indirizzamento aperto o le liste concatenate, ma all’utente la complessità resta comunque vicina a costante.

Una lista è concettualmente diversa: gli elementi sono ordinati in sequenza e vengono identificati da un indice numerico implicito (0, 1, 2…). Per accedere a un valore sapendo l’indice bastano pochi cicli di CPU, ma se si vuole cercare un elemento “per contenuto” bisogna scorrere la lista dall’inizio alla fine, con costo lineare O(n). Anche inserire o rimuovere in mezzo alla lista può richiedere lo spostamento di molti elementi.

Un insieme (set in Python) si appoggia internamente alla stessa logica di hashing, ma serve solo a dire se un oggetto è presente o no: non c’è alcun valore associato alla chiave, la “chiave” è l’oggetto stesso. In pratica un set è un dizionario dove ogni voce ha tutti i valori uguali, di solito un segnaposto; ciò che cambia davvero è l’intento d’uso, non il meccanismo sottostante.

Un esempio concreto in cui la tabella hash vince su qualunque altra struttura è il conteggio delle occorrenze di parole in un testo molto grande. Se dovessimo usare una lista per tenere le coppie parola-conteggio, ogni volta che incontriamo una parola dovremmo cercarla con un ciclo lineare e, se esiste, incrementarne il contatore: il tempo totale diventerebbe O(n²) nel caso peggiore. Con una tabella hash, invece, la parola stessa funge da chiave; basta un accesso diretto per leggere o creare il contatore, e l’intero conteggio richiede solo tempo lineare nella lunghezza del testo. Un set non sarebbe sufficiente, perché abbiamo bisogno non solo di sapere se la parola è già comparsa, ma anche di memorizzarne e aggiornare la frequenza.